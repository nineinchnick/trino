/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.server;

import com.google.common.collect.ImmutableList;
import com.google.common.io.ByteStreams;
import com.google.common.io.Files;
import io.airlift.log.Logger;
import io.trino.spi.Plugin;
import io.trino.spi.classloader.ThreadContextClassLoader;
import io.trino.spi.connector.ConnectorFactory;
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.AbstractMap.SimpleEntry;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.ServiceLoader;
import java.util.concurrent.Callable;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.Arrays.asList;
import static java.util.Objects.requireNonNull;

@Command(name = "modulesToConnectors", mixinStandardHelpOptions = true,
        description = "Maps Trino plugin modules to connectors they provide and filters them using a impacted modules list.")
public class PluginReader
        implements Callable<Integer>
{
    private static final Logger log = Logger.get(PluginReader.class);

    @Option(names = {"-i", "--impacted-modules"}, description = "Impacted modules file generated by the gitflow-incremental-builder (GIB) Maven plugin")
    private Optional<File> impactedModulesFile;

    @Option(names = {"-p", "--plugin-dir"}, description = "Trino plugin directory")
    private File pluginDir = new File("plugin");

    @Option(names = {"-r", "--root-pom"}, description = "Trino root module pom.xml")
    private File rootPom = new File("pom.xml");

    private PluginReader()
    {
    }

    public static void main(String... args)
    {
        int exitCode = new CommandLine(new PluginReader()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call()
            throws Exception
    {
        Optional<List<String>> impactedModules = Optional.empty();
        if (impactedModulesFile.isPresent()) {
            impactedModules = readImpactedModules(impactedModulesFile.get());
            if (impactedModules.isEmpty()) {
                return 1;
            }
        }
        Map<String, String> modulesToPlugins = mapModulesToPlugins(rootPom);
        Map<String, List<String>> pluginsToConnectors = mapPluginsToConnectors(pluginDir);
        Stream<Map.Entry<String, String>> modulesStream = requireNonNull(modulesToPlugins).entrySet().stream();
        if (impactedModules.isPresent()) {
            boolean hasNonPluginModules = impactedModules.get().stream().anyMatch(module -> !modulesToPlugins.containsKey(module));
            if (hasNonPluginModules) {
                log.warn("Impacted modules list includes non-plugin modules, ignoring it");
            }
            else {
                Optional<List<String>> finalImpactedModules = impactedModules;
                modulesStream = modulesStream.filter(entry -> finalImpactedModules.get().contains(entry.getKey()));
            }
        }
        modulesStream.forEach(entry -> {
            if (!pluginsToConnectors.containsKey(entry.getValue())) {
                log.warn("Plugin without any connectors: %s", entry.getValue());
                return;
            }
            pluginsToConnectors.get(entry.getValue())
                    .forEach(System.out::println);
        });
        return 0;
    }

    private static Map<String, String> mapModulesToPlugins(File rootPom)
    {
        Optional<List<String>> modules = readTrinoPlugins(rootPom);
        if (modules.isEmpty()) {
            return new HashMap<>();
        }
        return modules.get().stream()
                .map(module -> {
                    try {
                        Optional<Path> jarFile = java.nio.file.Files.find(Path.of(module, "target"),
                                1,
                                (path, basicFileAttributes) -> path.toFile().getName().matches(".*-services.jar")
                        ).findFirst();
                        if (jarFile.isPresent()) {
                            Optional<String> name = readPluginClassName(jarFile.get().toFile());
                            if (name.isPresent()) {
                                return new SimpleEntry<>(module, name.get());
                            }
                        }
                    }
                    catch (IOException e) {
                        log.error(e, "Couldn't read services jar for module %s", module);
                    }
                    log.warn("Couldn't find plugin name in services jar for module %s", module);
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private static Optional<List<String>> readTrinoPlugins(File rootPom)
    {
        try (FileReader fileReader = new FileReader(rootPom)) {
            MavenXpp3Reader reader = new MavenXpp3Reader();
            Model model = reader.read(fileReader);
            return Optional.of(
                    model.getModules().stream()
                            .filter(PluginReader::isTrinoPlugin)
                            .collect(toImmutableList()));
        }
        catch (IOException e) {
            log.warn(e, "Couldn't read file %s", rootPom);
            return Optional.empty();
        }
        catch (XmlPullParserException e) {
            log.warn(e, "Couldn't parse file %s", rootPom);
            return Optional.empty();
        }
    }

    private static boolean isTrinoPlugin(String module)
    {
        String modulePom = module + "/pom.xml";
        try (FileReader fileReader = new FileReader(modulePom)) {
            MavenXpp3Reader reader = new MavenXpp3Reader();
            Model model = reader.read(fileReader);
            return model.getPackaging().equals("trino-plugin");
        }
        catch (IOException e) {
            log.warn(e, "Couldn't read file %s", modulePom);
            return false;
        }
        catch (XmlPullParserException e) {
            log.warn(e, "Couldn't parse file %s", modulePom);
            return false;
        }
    }

    private static Optional<String> readPluginClassName(File serviceJar)
    {
        try {
            ZipFile zipFile = new ZipFile(serviceJar);
            Enumeration<? extends ZipEntry> e = zipFile.entries();

            while (e.hasMoreElements()) {
                ZipEntry entry = e.nextElement();
                if (entry.isDirectory() || !entry.getName().equals("META-INF/services/io.trino.spi.Plugin")) {
                    continue;
                }
                BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(entry));
                String fileContentsStr = new String(ByteStreams.toByteArray(bis), StandardCharsets.UTF_8).trim();
                bis.close();
                return Optional.of(fileContentsStr);
            }
        }
        catch (IOException e) {
            log.error(e, "Couldn't process service JAR %s " + serviceJar);
        }
        log.warn("Couldn't find 'META-INF/services/io.trino.spi.Plugin' file in the service JAR %s", serviceJar);
        return Optional.empty();
    }

    private static Optional<List<String>> readImpactedModules(File gibImpactedModules)
    {
        try {
            return Optional.of(Files.asCharSource(gibImpactedModules, StandardCharsets.UTF_8).readLines());
        }
        catch (IOException e) {
            log.warn(e, "Couldn't read file %s", gibImpactedModules);
            return Optional.empty();
        }
    }

    private static Map<String, List<String>> mapPluginsToConnectors(File path)
    {
        ServerPluginsProviderConfig config = new ServerPluginsProviderConfig();
        config.setInstalledPluginsDir(path);
        ServerPluginsProvider pluginsProvider = new ServerPluginsProvider(config, directExecutor());
        HashMap<String, List<String>> connectors = new HashMap<>();
        pluginsProvider.loadPlugins((plugin, createClassLoader) -> loadPlugin(createClassLoader, connectors), PluginManager::createClassLoader);
        return connectors;
    }

    private static void loadPlugin(Supplier<PluginClassLoader> createClassLoader, Map<String, List<String>> connectors)
    {
        PluginClassLoader pluginClassLoader = createClassLoader.get();
        try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(pluginClassLoader)) {
            loadServicePlugin(pluginClassLoader, connectors);
        }
    }

    private static void loadServicePlugin(PluginClassLoader pluginClassLoader, Map<String, List<String>> connectors)
    {
        ServiceLoader<Plugin> serviceLoader = ServiceLoader.load(Plugin.class, pluginClassLoader);
        List<Plugin> plugins = ImmutableList.copyOf(serviceLoader);
        checkState(!plugins.isEmpty(), "No service providers of type %s in the classpath: %s", Plugin.class.getName(), asList(pluginClassLoader.getURLs()));

        for (Plugin plugin : plugins) {
            connectors.put(plugin.getClass().getName(), getPluginConnectors(plugin));
        }
    }

    private static List<String> getPluginConnectors(Plugin plugin)
    {
        ImmutableList.Builder<String> connectorNames = ImmutableList.builder();

        for (ConnectorFactory connectorFactory : plugin.getConnectorFactories()) {
            connectorNames.add(connectorFactory.getName());
        }

        return connectorNames.build();
    }
}
